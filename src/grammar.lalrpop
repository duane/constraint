use std::str::FromStr;
use expr::{Scalar, RawLinearRelation, Relation};
use expr::RawLinearExpression;
use problem::{Problem, ProblemObjective, RawProblemObjective};
use var::Var;

grammar;

pub Scalar: Scalar = <s:r"-?[0-9]+\.?[0-9]*([eE]-?[0-9]+)?"> => f64::from_str(s).unwrap();

pub Variable: Var = <s:r"[_a-zA-Z][_a-zA-Z0-9]*"> => Var::external(String::from(s));

pub Term: (Option<Scalar>, Option<Var>) = {
  <s:Scalar> => (Some(s), None),
  <v:Variable> => (None, Some(v)),
  <s:Scalar> "*"? <v:Variable> => (Some(s), Some(v))
};

pub Expression: RawLinearExpression = {
  <e:(Term "+")*> <u:Term> => {
    let mut expr = RawLinearExpression::new();
    let mut terms: Vec<(Option<Scalar>, Option<Var>)> = e.into_iter().map(|t| t.0).collect();
    terms.push(u);
    for (scalar, var) in terms.into_iter() {
      let term = match (scalar, var) {
        (Some(scalar), Some(var)) => RawLinearExpression::term(var, scalar),
        (None, Some(var)) => RawLinearExpression::from(var),
        (Some(scalar), None) => RawLinearExpression::from(scalar),
        (None, None) => RawLinearExpression::new()
      };
      expr.plus_this(&term);
    }
    expr
  }
};

pub Relation: Relation = {
  "<" => Relation::LT,
  "<=" => Relation::LEQ,
  ">" => Relation::GT,
  ">=" => Relation::GEQ,
  "==" => Relation::EQ,
  "=!=" => Relation::NEQ
};

pub LinearRelation: RawLinearRelation = {
  <lhs:Expression> <o:Relation> <rhs:Expression> => RawLinearRelation::new(lhs, o, rhs)
};

pub ProblemObjective: RawProblemObjective = {
  "maximize(" <e:Expression> ")" => ProblemObjective::Maximize(e),
  "minimize(" <e:Expression> ")" => ProblemObjective::Minimize(e)
};

pub LINE_SEP = ";";

pub Problem: Problem = {
  <o: ProblemObjective> LINE_SEP+ <i:LinearRelation> <r:(LINE_SEP+ LinearRelation)*> => {
    let mut exprs: Vec<RawLinearRelation> = r.into_iter().map(|t|{t.1}).collect();
    exprs.push(i);
    Problem::new(o, exprs)
  }
};
